---
title: 음수는 비트로 어떻게 처리될까?
date: 2025-02-03
content: 부호 절대값, 1의 보수, 2의 보수
category: CS, All
---

# 3. 음수는 비트로 어떻게 처리될까요?
- 컴퓨터에서 음수를 표현하는 방법은 다음과 같이 3가지가 있습니다.
  1. 부호 절대값
  2. 1의 보수
  3. 2의 보수
    
## 3.1 부호 절대값

- **최상위 비트(가장 왼쪽의 비트)**를 부호 비트로 사용하고, 나머지 비트들은 해당 정수의 절대값을 이진수로 표현합니다.
- 이때 **최상위 비트(MSB)**는 부호를 나타냅니다.
  - **0**: 양수
  - **1**: 음수

### 예시

| 10진수 | 2진수 (양수) | 10진수 | 2진수 (음수) |
|--------|---------------------|--------|---------------------|
| 7      | 0111              | -7     | 1111              |
| 6      | 0110              | -6     | 1110              |
| 5      | 0101              | -5     | 1101              |
| 4      | 0100              | -4     | 1100              |
| 3      | 0011              | -3     | 1011              |
| 2      | 0010              | -2     | 1010              |
| 1      | 0001              | -1     | 1001              |
| 0      | 0000              | -0     | 1000              |

---

### 부호 절대값의 문제점

#### 0이 양수와 음수로 나뉜다.
- **0**이 양수와 음수로 각각 존재합니다. 예를 들어, +0과 -0이 모두 0000과 1000으로 표현됩니다.

#### 뺄셈에서 복잡성
- 두 수의 덧셈에서 음수가 껴있는 경우는 3가지가 있습니다.
  1. 두 수 모두 음수인 경우
  2. 첫 번째 수만 음수인 경우
  3. 두 번째 수만 음수인 경우
- **뺄셈 연산**에서 각 수가 양수인지 음수인지에 따라 복잡한 처리가 필요합니다.
- 예를 들어:
  1. 두 수 모두 양수이거나 음수인 경우:
   - 0001 0111 (23) + 0001 1111 (31) = 0011 0110(54) 
   - 1001 0111 (-23) + 1001 1111 (-31) = 1011 0110(-54)
   - MSB가 같다면 나머지 비트들을 더한 뒤 MSB만 그대로 내려오면 됩니다.
  2. 첫 번째 수가 음수인 경우
   - 1001 0111 (-23) + 0001 1111 (31) = +?-?54
   - MSB를 제외한 나머지 비트를 더하면 54가 나와버려 +-를 붙여도 올바른 답을 얻을 수가 없습니다.
   - 이러한 경우에는 절대값이 큰 수가 첫 번째 수가 되도록 하고 뺄셈을 해주면 됩니다.
   - 0001 1111 (31) - 0001 0111 (-23) = 0000 1000(8)
  3. 두 번째 수만 음수인 경우
   - 반대로 23이 양수이고 31이 음수라면 일단 큰 값에서 작은 값으로 빼준 뒤 그 결과 값에 음수를 취하면 됩니다.
   - 0001 0111 (23) + 1001 1111 (-31) 이런 상황이라면 0001 1111 (31) - 0001 0111 (23) = -(1000 1000)(-8)

### 장점
1. **직관적**: 최상위 비트만 고려하면 되므로, 사람 입장에서 직관적으로 이해하기 쉽습니다.
  
### 단점
1. **+0과 -0**: +0과 -0이 모두 존재하므로 이를 동일한 값으로 처리하도록 설계해야 합니다.
2. **복잡한 연산**: 연산에서 고려해야 할 조건들이 많아 회로가 복잡해지고, 부호 비트와 절대값을 각각 계산해야 하므로 구현이 복잡합니다.

## 3.2 1의 보수
- 1의 부소법은 해당 양수의 모든 비트를 반전하여 음수를 표현하는 방법입니다.
- 이 방법을 사용하면 음수를 비트 NOT 연산으로만 표현할 수 있어서 연산이 매우 간단해집니다.
- 부호 절대값에서 문제가 되었던 부호와 절대값을 따로 계산할 필요가 없습니다.
- 뺄셈 대신 음수를 더하기만 하면 되는 장점이 있습니다.

### 예시
| 10진수 | 2진수 (양수) | 10진수 | 1의 보수 (음수) |
|--------|---------------------|--------|---------------------|
| 7      | 0111              | -7     | 1000              |
| 6      | 0110              | -6     | 1001              |
| 5      | 0101              | -5     | 1010              |
| 4      | 0100              | -4     | 1011              |
| 3      | 0011              | -3     | 1100              |
| 2      | 0010              | -2     | 1101              |
| 1      | 0001              | -1     | 1110              |
| 0      | 0000              | -0     | 1111              |

### 부호 절대값의 문제점: 캐리(올림)이 발생하면 +1을 더해주어야 합니다.
- 0001 0111 (23) + 0001 1111 (31) = 0011 0110(54) 
- 1110 1000 (-23) + 0001 1111 (31) = 1 0000 0111 (7) MSB 자리를 넘어서 올림이 발생하면 +1을 해줍니다. 7 + 1 = 8
- 1110 1000 (-23) + 1110 0000 (-31) = 1 1100 1000 (-55) MSB 자리를 넘어서 올림이 발생하면 +1을 해줍니다. -55 + 1 = -54

### 장점
1. 양수의 비트만 반전시키면 음수값을 얻을 수 있습니다.
2. MSB의 성질이 유지가 됩니다.
3. 덧셈으로만 뺄셈을 구현할 수 있어 단순해집니다.
  
### 단점
1. 캐리가 발생하는 경우를 처리해주어야 합니다.
2. 부호 절대값과 같이 +0, -0을 처리해주어야 합니다.

## 2의 보수
- 1의 보수를 사용하면 +0, -0이 둘다 있고, 캐리가 발생하는 경우에 따라 +1을 해야했죠. 이러한 문제를 해결하는 간단한 방법은 음수 영역에서 -0을 없에는 것입니다.
- 음수 영역에서 각 대응되는 수를 -1씩 대응시키는 것입니다.
- 즉, 1의 보수 방식에서 +1을 한 값이 2의 보수 방식입니다.
### 예시
| 10진수 | 2진수 (양수) | 10진수 | 2의 보수 (음수) |
|--------|---------------------|--------|---------------------|
| 7      | 0111              | -7     | 1001              |
| 6      | 0110              | -6     | 1010              |
| 5      | 0101              | -5     | 1011              |
| 4      | 0100              | -4     | 1100              |
| 3      | 0011              | -3     | 1101              |
| 2      | 0010              | -2     | 1110              |
| 1      | 0001              | -1     | 1111              |
| 0      | 0000              |

### 덧셈 예시
- 0001 0111 (23) + 0001 1111 (31) = 0011 0110 (54) 
- 1110 1001 (-23) + 0001 1111 (31) = 1 0000 1000 (8)
-  1110 1001 (-23) + 1110 0001 (-31) = 1 1100 1010 (-54) 
-  0001 0111 (23) + 1110 0001 = 1 1111 1000 (-8)
- 위 처럼 캐리가 발생하더라고 올바른 값이 나옵니다.

### 장점
1. 1의 보수에 +1을 하면 음수값을 얻을 수 있습니다.
2. MSB 성절이 유지됩니다.
3. 덧셈만으로 뺄셈을 구현할 수 있어 단순해집니다.
4. 1의 보수의 단점(캐리, 0이 두개 문제)이 모두 해결됩니다.
- 이 때문에 현재 대부분의 컴퓨터에서는 2의 보수법으로 음수를 표현하고 있습니다.

출처:
- [TCP School음수의 표현](https://www.tcpschool.com/c/c_refer_negativeNumber)
- [2진수의 수와 음수 표현법](https://st-lab.tistory.com/189)

-----